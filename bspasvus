#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Auteur : Romain RICHARD <romain.richard.it.engineer@gmail.com>

from xml.dom import minidom
from xml.sax.saxutils import escape
from urllib import urlencode, quote, urlretrieve
import urllib2

import hashlib
import sys
import os
import re
import zipfile


##########################################
# Classe pour utiliser l'API BetaSeries. #
##########################################
class api:

	# Constructeur de la classe.
	# @param string key : Clé développeur.
	def __init__(self, key):
		self.key = key
		self.token = ''

	# Configure le token de l'utilisateur.
	# @param string token : Token de l'utilisateur.
	def set_token(self, token):
		self.token = token

	# Envoie une requête sur l'API
	# @param string url : URL de l'API à appeler.
	# @param array vars : Tableau des variables éventuelles à renseigner.
	# @return object : Objet parsé par minidom du retour de l'API.
	def send_request(self, url, vars):
		url += '?key=' + self.key + '&token=' + self.token

		for key, value in vars.items():
			url += '&' + urlencode({key:value})

		data = urllib2.urlopen(url).read()

		xml = minidom.parseString(data)

		return xml



#######################################################
# Classe pour afficher la liste des épisodes pas vus. #
#######################################################
class BSPasVus:

	# Constructeur de la classe.
	def __init__(self, base_config = "~/.BetaSeries/"):
		self.__api           = None
		self.__api_url       = "http://api.betaseries.com/"
		self.__order_file = os.path.expanduser(base_config + "order.xml")
		self.__key           = "f3df045397dc"
		self.__login         = None
		self.__password      = None
		self.__token         = ""
		self.__auth_url      = self.__api_url + "members/auth.xml"
		self.__infos_url     = self.__api_url + "members/infos.xml"
		self.__infos         = None
		self.__all_url       = self.__api_url + "members/episodes/all.xml"
		self.__all           = None
		self.__watched_url   = self.__api_url + "members/watched/"
		self.__number        = -1
		self.__cut           = -1
		self.__folder        = ""
		self.__one           = False
		self.__watched       = False
		self.__subtitles     = ""
		self.__subtitles_url = self.__api_url + "subtitles/show.xml"
		self.__playlist      = os.path.expanduser(base_config + "playlist.pls")

		base = os.path.dirname(self.__order_file)
		if not os.path.exists(base):
			try:
				os.makedirs(base)
			except OSError, e:
				error(e)

		self.load_config_file(os.path.expanduser(base_config + "config"))

	# Charge le fichier de configuration
	def load_config_file(self, path):
		try:
			fd = open(path, 'r')
		except IOError:
			return

		conf = {}
		lines = fd.readlines()
		pattern = re.compile("(\S+)\s+=\s+(.+)")
		for l in lines:
			if l[0] == '#':
				continue

			r = re.match(pattern, l)

			try:
				conf[r.group(1)] = r.group(2)
			except AttributeError:
				continue
			except IndexError:
				continue

		fd.close()
		self.set_config(conf)

	# Configure les options.
	def set_config(self, conf):
		for k in conf.keys():
			val = conf[k]
			if val == None:
				continue
			elif k == "login":
				self.__login = val
			elif k == "password":
				self.__password = val
			elif k == "folder":
				self.__folder = val
			elif k == "cut":
				self.__cut = int(val)
			elif k == "number":
				self.__number = int(val)-1
			elif k == "one":
				self.__one = (val == 'True')
			elif k == "watched":
				self.__watched = (val == 'True')
			elif k == "subtitles":
				self.__subtitles = val

	def get_login(self):
		return self.__login

	def get_password(self):
		return self.__password

	# Récupère les fichier xml contenant la liste des épisodes pas vus ainsi que les infos de l'utilisateur.
	def download_xml(self):
		# Construction de la classe avec la clé API.
		self.__api = api(self.__key)

		# Appel de l'API pour identifier l'utilisateur.
		xmldoc = self.__api.send_request(self.__auth_url, {'login':self.__login, 'password':hashlib.md5(self.__password).hexdigest()})

		# On met le token de l'utilisateur dans une variable
		# et on configure la classe avec celle-ci.
		self.__token = xmldoc.getElementsByTagName('token')[0].firstChild.data
		self.__api.set_token(self.__token)

		# Appel de l'API pour récupérer les infos de l'utilisateur.
		self.__infos = self.__api.send_request(self.__infos_url, {})

		# Appel de l'API pour récupérer la liste des épisodes pas vus.
		self.__all = self.__api.send_request(self.__all_url, ({'view':'next'} if (self.__one) else {}))



	# Crée le fichier XML avec les séries ordonnées
	def order_shows(self):
		# La liste des séries non archivées de l'utilisateur
		liste_series = "<?xml version=\"1.0\" ?><root>"
		for i in range (0, self.__infos.getElementsByTagName('show').length):
			if (self.__infos.getElementsByTagName('archive')[i].firstChild.data == '0'):
				# On escape le nom car s'il contient '&amp;' il sera transformé en '&'
				liste_series += "\n\t<show>" + escape(self.__infos.getElementsByTagName('title')[i].firstChild.data) + "</show>"
		liste_series += "\n</root>"
		liste_series_xml = minidom.parseString(liste_series.encode('utf-8'))

		# La liste ordonnée des séries non archivées de l'utilisateur
		series_ordonnees = "<?xml version=\"1.0\" ?><root>"

		order_file_xml = None

		# Est-ce que le fichier self.__order_file existe ?
		if (os.path.isfile(self.__order_file)):
			# Le fichier self.__order_file converti en xml
			fd = open(self.__order_file, 'r')
			order_file_xml = minidom.parse(fd)
			fd.close()

			# Supprimer les séries qui ont été archivées/supprimées
			for i in range (0, order_file_xml.getElementsByTagName('show').length):
				serie = escape(order_file_xml.getElementsByTagName('show')[i].firstChild.data)

				# On cherche si la série est dans liste_series_xml
				est_dans_liste_series_xml = False
				for j in range (0, liste_series_xml.getElementsByTagName('show').length):
					if (escape(liste_series_xml.getElementsByTagName('show')[j].firstChild.data) == serie):
						est_dans_liste_series_xml = True

				# On n'ajoute que les séries qui sont dans liste_series_xml
				if (est_dans_liste_series_xml):
					series_ordonnees += "\n\t<show>" + serie + "</show>"

			# Ajouter les nouvelles séries
			for i in range (0, liste_series_xml.getElementsByTagName('show').length):
				# On escape le nom car s'il contient '&amp;' il sera transformé en '&'
				serie = escape(liste_series_xml.getElementsByTagName('show')[i].firstChild.data)
				
				# On cherche si la série est dans order_file_xml
				est_dans_order_file_xml = False
				for j in range (0, order_file_xml.getElementsByTagName('show').length):
					if (escape(order_file_xml.getElementsByTagName('show')[j].firstChild.data) == serie):
						est_dans_order_file_xml = True

				# On n'ajoute que les séries qui ne sont pas dans order_file_xml
				if (not est_dans_order_file_xml):
					series_ordonnees += "\n\t<show>" + serie + "</show>"
		# Le fichier self.__order_file n'existe pas
		else:
			# Ajouter les séries
			for i in range (0, liste_series_xml.getElementsByTagName('show').length):
				# On escape le nom car s'il contient '&amp;' il sera transformé en '&'
				serie = escape(liste_series_xml.getElementsByTagName('show')[i].firstChild.data)
				
				# On ajoute la série
				series_ordonnees += "\n\t<show>" + serie + "</show>"

		series_ordonnees += "\n</root>"

		# On compare le contenu de self.__order_file et de series_ordonnees
		# S'il est différent, on copie series_ordonnees dans self.__order_file
		if (order_file_xml == None or order_file_xml.toxml() != series_ordonnees):
			fd = open(self.__order_file, 'w')
			fd.write(series_ordonnees.encode('utf-8'))
			fd.close()
			# Si on ne demande pas un numéro précis de série, on affiche le message
			if (self.__number < 0):
				output("Modifiez le fichier order.xml")

	# Trie le fichier xml en fonction des priorités.
	def sort_xml(self):
		try:
			fd = open(self.__order_file, 'r')
		except IOError:
			return
		order = minidom.parse(fd)
		fd.close()

		# Le nouveau fichier xml qui va contenir les épisodes triés
		all_new = "<?xml version=\"1.0\" ?><root>"

		# On parcourt le fichier self.__order_file
		for i in range (0, order.getElementsByTagName('show').length):
			serie = order.getElementsByTagName('show')[i].firstChild.data
			serie_j = -1

			# On parcourt le fichier self.__all
			for j in range (0, self.__all.getElementsByTagName('show').length):
				if (serie == self.__all.getElementsByTagName('show')[j].firstChild.data):
					serie_j = j

			if (serie_j != -1): # Il y a un épisode pas vus de la série serie
				all_new += self.__all.getElementsByTagName('episode')[2*serie_j].toxml()

		all_new += "\n</root>"
		self.__all = minidom.parseString(all_new.encode('utf-8'))



	# Affiche la liste d'épisodes.
	def display(self):
		# Il y a deux tags <episode> par épisode pas vu
		l     = self.__all.getElementsByTagName('episode').length/2

		begin = 0
		end   = l
		if (self.__number >= 0):
			begin = self.__number
			end   = self.__number + (self.__number < l)

		for i in range(begin, end):
			show    = self.__all.getElementsByTagName('show')[i].firstChild.data
			episode = self.__all.getElementsByTagName('episode')[2*i+1].firstChild.data
			title   = ('' if (self.__all.getElementsByTagName('title')[i].firstChild == None) else self.__all.getElementsByTagName('title')[i].firstChild.data)
			show    = show[0:self.__cut if (self.__cut >= 0) else len(show)]
			output(show + ' ' + episode + ' ' + title)



	# Récupère les adresses des épisodes pas vus et enregistre la playlist
	def create_playlist(self):
		playlist = ''
		# Pour ne pas récupérer les url des srt
		decalage_url = 0
		for i in range(0, self.__all.getElementsByTagName('episode').length/2):
			adresse = unicode(self.__folder, 'utf-8')
			
			show    = self.__all.getElementsByTagName('show')[i].firstChild.data
			# 2*i+1 car il y a 2 tags <episode> pour chaque episode non vu, le 2nd - qui nous intéresse - contient le numéro de saison et d'épisode
			episode = self.__all.getElementsByTagName('episode')[2*i+1].firstChild.data
			# On ne veut pas les url des srt (http://www.betaseries.com/srt/*****) mais de la serie (le nom)
			while(self.__all.getElementsByTagName('url')[i+decalage_url].firstChild.data.startswith('http')):
				decalage_url += 1
			serie_url = self.__all.getElementsByTagName('url')[i+decalage_url].firstChild.data

			# Récupère le nom du fichier s'il existe
			if (os.path.isdir(adresse)):
				nom = None
				# Chercher un fichier commençant par show.episode
				fichiers = []
				for root, subFolders, files in os.walk(adresse):
					for file in files:
						fichiers.append(os.path.join(root.replace(adresse,''),file))
				for j in range(0, len(fichiers)):
					if (self.match(fichiers[j], show, episode)):
						nom = fichiers[j]
				# Si un fichier a été trouvé, on l'ajoute à la playlist
				if (nom != None):
					playlist += 'File' + str(2*i) + '=' + adresse + nom + '\n'
					if (self.__watched):
						playlist += 'File' + str(2*i+1) + '=' + self.__watched_url + serie_url + '.xml?key=' + self.__key + '&token=' + self.__token + '&season=' + episode[1:3] + '&episode=' + episode[4:6] + '\n'
					# On se sert du nom du fichier pour récupérer si nécessaire les sous-titres
					#if ((self.__subtitles == "VF" or self.__subtitles == "VO") and not os.path.isfile(adresse + os.path.splitext(nom)[0] + '.srt')):
					if (self.__subtitles == "VF" or self.__subtitles == "VO"):
						quality = 0
						# S'il y a déjà un sous-titre de présent, on essaye de récupérer sa qualité
						for j in range(0, len(fichiers)):
							if (fichiers[j].startswith(os.path.splitext(nom)[0]) and fichiers[j].endswith('srt')):
								quality_tmp = os.path.splitext(fichiers[j].split('/')[-1])[0].replace(os.path.splitext(nom.split('/')[-1])[0], '').replace('.', '')
								if (quality_tmp != ''):
									quality = int(quality_tmp)
						self.download_subtitles(serie_url, nom, quality)

		# Enregistre la playlist
		fd = open(self.__playlist, 'w')
		fd.write(playlist.encode('utf-8'))
		fd.close()

	# Regexp sur le nom du fichier
	# /!\ Les dossiers contenant chaque série doivent avoir le même nom que la série sur betaseries (à part pour les animes où le '(JP)' n'est pas nécessaire
	def match(self, fichier, show, episode):
		fichier = fichier.replace('_', '.')
		fichier = fichier.replace(' ', '.')
		show = show.replace(' ', '.')
		
		# TODO Trouver une meilleure solution
		# Problème avec The Good Guys (2010) (et accessoirement Bleach (JP))
		show = show.split('.(').pop(0)
		fichier = fichier.replace('2010.', '')
		
		# Serie.S03E02
		# Serie.302
		# Serie.3x02
		# Serie S03E02
		# Serie 302
		# Serie 3x02
		# Serie - S03E02
		# Serie - 302
		# Serie - 3x02
		# Serie/Saison 3/Serie.S03E02 ...
		# Serie/Serie.S03E02 ...
		# Serie/Saison 3/02
		# Serie/02 = Serie.S01E02
		r = re.match("((.*?)[/\\\\])*?(?P<f_show>.*?)[.]([\\\\/]?[sS]?((ai|ea)son)?\.?(?P<f_season>\\d{1,2})[/\\\\]?[eEx]?)(?P<f_episode>\\d{2}).*(avi|mkv|mp4)$", fichier)
		
		# TODO Trouver une meilleure solution
		f_show = ''
		if (r != None):
			f_show = r.group('f_show').upper()
		# Problème avec (par ex) : How.Not.to.Live.Your.Life/Saison.3/05.Don.Dates.A.Homeless.HDTV.XviD-FoV.avi
		# On se retrouve avec f_show = Saison
		if (r != None and (r.group('f_show').upper() == "SEASON" or r.group('f_show').upper() == "SAISON")):
			#output('OUPS ! ' + show)
			ra = re.match("(?P<f_show>.*?)/(.*?)", fichier)
			f_show = ra.group('f_show').upper()
		
		return (
				r != None and
				f_show.startswith(show.upper()) and
				episode[1:3].endswith(('01' if (r.group('f_season') == None) else r.group('f_season'))) and
				episode[4:6].endswith(r.group('f_episode'))
				)

	# Télécharge le sous-titres de l'épisode
	def download_subtitles(self, serie_url, nom, quality):
		# nom peut contenir des dossiers, on sépare alors les dossiers et le nom du fichier
		path = unicode(self.__folder, 'utf-8')
		for i in range(0, len(nom.split('/'))-1):
			path += nom.split('/')[i] + '/'
		filename = os.path.splitext(nom.split('/')[-1])[0]
		
		# On récupère les sous-titres correspondant à l'épisode
		subtitles = self.__api.send_request(self.__subtitles_url, {'file':filename, 'language':self.__subtitles})
		
		# Télécharger les sous-titres
		if (subtitles.getElementsByTagName('file') != []):
			# On cherche le sous-titre de meilleure qualité
			best_quality = 0
			best_quality_i = 0
			for i in range(0, subtitles.getElementsByTagName('quality').length):
				if (int(subtitles.getElementsByTagName('quality')[i].firstChild.data) > best_quality):
					best_quality = subtitles.getElementsByTagName('quality')[i].firstChild.data
					best_quality_i = i
			
			# S'il y a un sous-titre de meilleure qualité que celui que l'on possède déjà, on le télécharge
			if (int(best_quality) > quality):
				subtitle = path + subtitles.getElementsByTagName('file')[best_quality_i].firstChild.data
				urlretrieve(subtitles.getElementsByTagName('url')[best_quality_i].firstChild.data, subtitle)
			
				# On récupère l'extension du fichier téléchargé
				extension = os.path.splitext(subtitle)[-1]
			
				# Si on a téléchargé un .zip, le décompresser
				if (extension == '.zip'):
					# Dézipper
					tmp = zipfile.ZipFile(subtitle, 'r').namelist()[0]
					zipfile.ZipFile(subtitle, 'r').extractall(path)
					# Supprimer le fichier zip
					os.remove(subtitle)
					# Récupérer le nom du fichier que l'on vient de dézipper
					subtitle = path + tmp
		
				# Renommer le fichier srt pour correspondre au nom de la vidéo
				os.rename(subtitle, path + filename + '.' + best_quality + '.srt')
				
				# S'il y avait un fichier sous-titres d'une qualité moindre, on le supprime
				if (quality > 0):
					os.remove(path + filename + '.' + str(quality) + '.srt')



	# Affiche l'aide
	def show_help(self):
		output("Usage: bspasvus <options>")
		output("Options list:")
		output("-h|--help                  : This helpful message")
		output("-l|--login \"<login>\"       : Your login")
		output("-p|--password \"<password>\" : Your password")
		output("-f|--folder \"<folder>\"     : Folder where the episodes are")
		output("-c|--cut <num>             : Length max for the name of the show")
		output("-n|--number <num>          : Display the n-th show")
		output("-o|--one                   : Display only one episode for each show")
		output("-w|--watched               : Add an item to the playlist to mark the episode as watched")
		output("-s|--subtitles \"language\"  : Download subtitles in the language (VO|VF) you want")




# Affiche un message d'erreur et quitte
def error(err):
	print >>sys.stderr, err
	sys.exit(1)

# Affiche du texte à l'écran
def output(str):
	print >>sys.stdout, unicode(str).encode("UTF-8")

# Le main
def main():
	bspasvus = BSPasVus()

	conf = {}
	i = 1
	while i < len(sys.argv):
		arg = sys.argv[i]

		try:
			val = sys.argv[i + 1]
		except IndexError:
			val = None

		if arg == "-h" or arg == "--help":
			bspasvus.show_help()
			sys.exit(0)
		elif arg == "-l" or arg == "--login":
			conf['login'] = val
			i += 1
		elif arg == "-p" or arg == "--password":
			conf['password'] = val
			i += 1
		elif arg == "-c" or arg == "--cut":
			conf['cut'] = val
			i += 1
		elif arg == "-f" or arg == "--folder":
			conf['folder'] = val
			i += 1
		elif arg == "-n" or arg == "--number":
			conf['number'] = val
			i += 1
		elif arg == "-o" or arg == "--one":
			conf['one'] = 'True'
			i += 1
		elif arg == "-w" or arg == "--watched":
			conf['watched'] = 'True'
			i += 1
		elif arg == "-s" or arg == "--subtitles":
			conf['subtitles'] = val
			i += 1
		else:
			error("[ERROR] Unknown option: %s" % arg)

		i += 1

	bspasvus.set_config(conf)
	if (bspasvus.get_login() == None or bspasvus.get_password() == None):
		output('You must enter your login and password')
	else:
		bspasvus.download_xml()
		bspasvus.order_shows()
		bspasvus.sort_xml()
		bspasvus.display()
		bspasvus.create_playlist()
	sys.exit(0)

if __name__ == '__main__':
	main()
